# импортируем сторонние стандартные модули Python3
import os  # взаимодействие с системой для указания пути к файлам, их загрузке и выгрузке

import matplotlib.image as mpimg  # модуль для загрузки исходного файла с изображением
import matplotlib.pyplot as plt  # модуль для отрисовки полотна с изображением
import numpy as np  # модуль для обработки и вычислений
from scipy import (
    fftpack,
)  # модуль позволяет выполнить ДКП - реализация функций в открытом доступе (англ.)

# некоторые функции были  вынесены в отдельные файлы, которые необходимо импортировать как модули
import zigzag_scan  # импортируем скрипт для развертки исходной матрицы ДКП в змеевидном порядке

IMAGE_NAME = "sample_image.png"  # указываем здесь наименование изображения

# =========================================================================
# получаем полутоновое растровое изображение - исходный пустой контейнер

# получаем путь к текущей директории (где находится скрипт)
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
# получаем полный путь к изображению (включая его название)
IMAGE_FILE = os.path.join(CURRENT_DIR, IMAGE_NAME)
# выводим полный путь к изображению в консоль
print(IMAGE_FILE)


def rgb2gray(rgb):
    """Преобразование исходного RGB в оттенки серого

    Данная функция позволяет преобразвать исходное изображение в полутоновое растровое,
    что будет являться контейнером
    """
    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])


# получаем файл с изображением и преобразуем его в контейнер, используя функцию rgb2gray
# функция rgb2gray представлена выше
img = mpimg.imread(IMAGE_FILE)
EMPTY_CONTAINER = rgb2gray(img)

# сохраним полученный контейнер в файле CONTAINER.png


# =========================================================================
# прямое косинусное преобразование
dctforw = fftpack.dct(fftpack.dct(EMPTY_CONTAINER.T, norm="ortho").T, norm="ortho")

# проходим по матрице элементов ДКП зигзагом и на основе этого создаем новую матрицу
# матрица zigzagmatrix содержит индексы и значения элементов,
# элементы расположены в соответствие с порядком "змеевидного" прохода по исходной матрице
zigzagmatrix = zigzag_scan.zigzagscan(dctforw)

print(type(zigzagmatrix))

zigzaglen = len(zigzagmatrix)  # количество элементов в матрице

# проходим по zigzagmatrix, сортируем её по возрастанию элементов (последний элемент будет наибольшим)
# после сортировки берем 1000 наибольших элементов (срез с конца полученной матрицы)
# maxel = zigzagmatrix[zigzagmatrix[:, 2].argsort()]
# print(zigzagmatrix)
# матрица maxel содержит 1000 наибольших элементов и их индексы

# идем по матрице zigzagmatrix
# если находим совпадение по значению с maxel - if zigzagmatrix[n][2] in maxel[n][2]
# то такой элемент добавляем в новую матрицу наибольших элементов в соответствии с порядком в zigzagmatrix
# в данном случае порядок будет равен n

# перейдем к массиву из наибольших значений
# maxel_arr = []
# print(maxel)


# ====================================================================================

# выведем значения элементов матрицы в отдельный массив elements_values
elements_values = []
for i in range(zigzaglen):
    elements_values.append(zigzagmatrix[i][2])

# ====================================================================================

# отбираем индексы у 1000 наибольших значений из elements_values
N = 1000
max_elements_idx = np.argsort(elements_values)[-N:]

max_elements = []
for idx in max_elements_idx:
    max_elements.append(elements_values[idx])

# теперь по порядку проходим матрицу zigzagmatrix и элементы, значения которых есть
# среди массива с 1000 наибольших элементов
# заносим в отдельную матрицу relevant_matrix
# новая матрица будет содержать наибольшие элементы в соответствие со змеевидным порядком
# print(max_elements)
# print(len(max_elements))
# a = zigzagmatrix[zigzagmatrix[:, 2].np.argsort()]

relevant_matrix = []
for row in zigzagmatrix:
    if row[2] in max_elements:
        relevant_matrix.append(row)

print(relevant_matrix)

# ====================================================================================
# модифицируем значения элементов в конечной матрице,
# которая представляет собой пространство признаков
# увеличиваем значения в третьем столбце в матрице relevant_matrix
for row in relevant_matrix:
    # встроим значение Omega равное пяти
    row[2] += 5 * 0.02  # 0.02 - весовой коэффициент alpha для снижения искажений от встраивания

print(relevant_matrix)
# ====================================================================================
# вставим модифицированные значения в матрицу ДКП в соответствие с их индексами

for row in relevant_matrix:
    dctforw[row[0]][row[1]] = row[2]

print(dctforw[0][1])
# ====================================================================================

# выведем значения из массивов в отдельные файлы elements_values.txt и max_elements.txt
# with open('elements_values.txt', 'w') as ouf:
#     for el in elements_values:
#         ouf.write(str(el) + '\n\r')


# with open('max_elements.txt', 'w') as ouf2:
#     for el1 in max_elements:
#         ouf2.write(str(el1) + '\n\r')

# ====================================================================================
# проводим обратное ДКП и формируем заполненный контейнер, который затем сохраним
# в файл FULL_CONTAINER.png

# обратное косинусное преобразование
FULL_CONTAINER = fftpack.idct(fftpack.idct(dctforw.T, norm="ortho").T, norm="ortho")

# выводим полученное после преобразований изображение-контейнер
plt.imshow(FULL_CONTAINER, cmap=plt.get_cmap("gray"), vmin=0, vmax=1)
plt.show()
